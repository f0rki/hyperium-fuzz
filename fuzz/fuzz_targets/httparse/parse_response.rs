#![no_main]

const PREALLOCATED_HEADERS: usize = 128;
const GRAMMAR_NEW_PROB: f64 = 0.3;
const GRAMMAR_DEFAULT_DEPTH: usize = 1024;

use arbitrary::Arbitrary;

#[cfg(feature = "use_libfuzzer")]
use libfuzzer_sys::{fuzz_mutator, fuzz_target, Corpus};

#[cfg(feature = "use_libafl")]
use cargo_libafl_helper::fuzz_target;

#[cfg(all(feature = "use_libfuzzer", feature = "use_grammar"))]
fuzz_mutator!(|data: &mut [u8], size: usize, max_size: usize, seed: u32| {
    use hyperium_fuzz_utils::f0_httpresponse_generator::GrammarGenerator;
    use rand::prelude::*;

    // this is a bit of a hack. arbitrary conumes one byte for Option and one byte for every
    // boolean. So we just prefix our grammar-generated bytes with this to generate a parser config
    // with all "false" boolean values.
    let mut parser_config_bytes = [1u8, 0, 0, 0, 0, 0];

    let seed = seed as u128;
    let seed = (seed << 96) | (seed << 64) | (seed << 32) | seed;
    let mut rng = rand_pcg::Pcg64Mcg::new(seed);

    let gen_new = data.len() == 0 || rng.gen_bool(GRAMMAR_NEW_PROB);
    if gen_new {
        // generate a new request with the grammar generator
        let new_data = GrammarGenerator::generate_new(Some(GRAMMAR_DEFAULT_DEPTH), &mut rng);
        // also mutate the bytes for the parser config
        let cl = parser_config_bytes.len();
        libfuzzer_sys::fuzzer_mutate(&mut parser_config_bytes, cl, cl);

        let off = parser_config_bytes.len();
        let new_len = std::cmp::min(max_size, new_data.len() + off);
        data[..off].copy_from_slice(&parser_config_bytes);
        data[off..new_len].copy_from_slice(&new_data[0..(new_len - off)]);
        new_len
    } else {
        libfuzzer_sys::fuzzer_mutate(data, size, max_size)
    }
});

fn parse(config: Option<HttparserConfig>, data: &[u8]) -> bool {
    let mut headers = [httparse::EMPTY_HEADER; PREALLOCATED_HEADERS];
    let mut resp = httparse::Response::new(&mut headers);

    // println!("{:?}", config);
    // println!("{}", String::from_utf8_lossy(data));

    match config {
        Some(fuzzed_config) => httparse::ParserConfig::default()
            .allow_spaces_after_header_name_in_responses(fuzzed_config.0)
            .allow_obsolete_multiline_headers_in_responses(fuzzed_config.1)
            .allow_multiple_spaces_in_request_line_delimiters(fuzzed_config.2)
            .allow_multiple_spaces_in_response_status_delimiters(fuzzed_config.3)
            .ignore_invalid_headers_in_responses(fuzzed_config.4)
            .parse_response(&mut resp, data)
            .is_ok(),
        None => resp.parse(data).is_ok(),
    }
}

// NOTE: if you change the type you need to adapt the fuzz_mutator!!!
#[derive(Debug, Clone, Copy, Arbitrary)]
struct HttparserConfig(bool, bool, bool, bool, bool);

#[cfg(feature = "use_libfuzzer")]
fuzz_target!(|fuzzed_data: (Option<HttparserConfig>, &[u8])| -> Corpus {
    if fuzzed_data.1.is_empty() {
        return Corpus::Reject;
    }

    if parse(fuzzed_data.0, fuzzed_data.1) {
        Corpus::Keep
    } else {
        Corpus::Reject
    }
});

#[cfg(not(feature = "use_libfuzzer"))]
fuzz_target!(|fuzzed_data: (Option<HttparserConfig>, &[u8])| {
    if fuzzed_data.1.is_empty() {
        return;
    }
    parse(fuzzed_data.0, fuzzed_data.1);
});
